// Generated by CoffeeScript 1.9.1
(function() {
  $(document).ready(function() {
    var HEIGHT, MAX_DIST, NODES, RANDOM, SPACING, WIDTH, WIND_SPEED, applyGravity, calcDistance, createRope, getId, getLinks, i, isLinkAtMax, isWindBlowing, j, link, links, node, nodes, randomColor, recursiveAnim, render, svg, update;
    WIDTH = $(document).width();
    HEIGHT = $(document).height();
    MAX_DIST = 50;
    RANDOM = 40;
    SPACING = 50;
    NODES = 30;
    nodes = [];
    links = [];
    isWindBlowing = false;
    WIND_SPEED = 0.5;
    randomColor = function() {
      return '#' + Math.floor(Math.random() * 16777215).toString(16);
    };
    getId = function() {
      return nodes.length;
    };
    createRope = function(sx, sy, segments, length) {
      var i, id, j, node, ref, results, step, x, y;
      x = sx;
      y = sy;
      step = length / segments;
      results = [];
      for (i = j = 0, ref = segments; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        node = {
          x: x + Math.random() * RANDOM - RANDOM / 2,
          y: y,
          vy: 0,
          fill: randomColor()
        };
        y += step;
        id = getId();
        if (i > 0) {
          links.push({
            source: id - 1,
            target: id
          });
        } else {
          node.fixed = true;
        }
        results.push(nodes.push(node));
      }
      return results;
    };
    for (i = j = 0; j <= 40; i = ++j) {
      createRope(-200 + i * SPACING, -200, NODES, 1);
    }
    svg = d3.select('body').append('svg').attr('width', WIDTH).attr('height', HEIGHT);
    $(window).on('resize', function() {
      console.log('here');
      svg.attr('width', $(document).width());
      return svg.attr('height', $(document).height());
    });
    link = svg.selectAll('.link').data(links).enter().append('line');
    node = svg.selectAll('.node').data(nodes).enter().append('circle');
    getLinks = function(index) {
      var k, len, li, ls;
      ls = [];
      for (i = k = 0, len = links.length; k < len; i = ++k) {
        li = links[i];
        if (li.target === index) {
          if (ls.indexOf(li.target === -1)) {
            ls.push(li);
          }
        }
        if (li.source === index) {
          if (ls.indexOf(li.source === -1)) {
            ls.push(li);
          }
        }
      }
      return ls;
    };
    calcDistance = function(s, t) {
      var dx, dy;
      dx = s.x - t.x;
      dx *= dx;
      dy = s.y - t.y;
      dy *= dy;
      return Math.sqrt(dx + dy);
    };
    isLinkAtMax = function(index) {
      var apply, dist, k, l, len, ls;
      ls = getLinks(index);
      apply = true;
      for (k = 0, len = ls.length; k < len; k++) {
        l = ls[k];
        dist = calcDistance(nodes[l.source], nodes[l.target]);
        if (dist > MAX_DIST) {
          apply = false;
        }
      }
      return apply;
    };
    applyGravity = function(index) {
      var G;
      if (nodes[index].fixed) {
        return;
      }
      G = 0.2;
      if (isLinkAtMax(index)) {
        nodes[index].vy += G;
        return nodes[index].y += nodes[index].vy;
      } else {
        return nodes[index].vy = 0;
      }
    };
    update = function() {
      var index, k, len, n, results;
      results = [];
      for (index = k = 0, len = nodes.length; k < len; index = ++k) {
        n = nodes[index];
        results.push(applyGravity(index));
      }
      return results;
    };
    render = function() {
      node.attr('cx', function(d) {
        return d.x;
      }).attr('cy', function(d) {
        return d.y;
      }).attr('r', function(d) {
        return 5;
      }).style('fill', function(d) {
        return d.fill;
      });
      return link.attr('x1', function(d) {
        return nodes[d.source].x;
      }).attr('y1', function(d) {
        return nodes[d.source].y;
      }).attr('x2', function(d) {
        return nodes[d.target].x;
      }).attr('y2', function(d) {
        return nodes[d.target].y;
      }).style('stroke', function(d) {
        return randomColor();
      });
    };
    setInterval(function() {
      return update();
    }, 1);
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
        return setTimeout(render, 1000 / 60);
      };
    })();
    return (recursiveAnim = function() {
      render();
      return requestAnimationFrame(recursiveAnim);
    })();
  });

}).call(this);
